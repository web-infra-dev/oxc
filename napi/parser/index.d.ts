/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ImportSpecifier {
  /**
   * Module name
   *
   * To handle escape sequences in specifier strings, the .n field of imported specifiers will be provided where possible.
   *
   * For dynamic import expressions, this field will be empty if not a valid JS string.
   */
  n?: string
  /** Start of module specifier */
  s: number
  /** End of module specifier */
  e: number
  /** Start of import statement */
  ss: number
  /** End of import statement */
  se: number
  /**
   * Import Type
   * * If this import keyword is a dynamic import, this is the start value.
   * * If this import keyword is a static import, this is -1.
   * * If this import keyword is an import.meta expression, this is -2.
   */
  d: number
  /**
   * If this import has an import assertion, this is the start value
   * Otherwise this is `-1`.
   */
  a: number
}
export interface ExportSpecifier {
  /** Exported name */
  n: string
  /** Local name, or undefined. */
  ln?: string
  /** Start of exported name */
  s: number
  /** End of exported name */
  e: number
  /** Start of local name */
  ls?: number
  /** End of local name */
  le?: number
}
export interface ModuleLexer {
  imports: Array<ImportSpecifier>
  exports: Array<ExportSpecifier>
  /**
   * ESM syntax detection
   *
   * The use of ESM syntax: import / export statements and `import.meta`
   */
  hasModuleSyntax: boolean
  /** Facade modules that only use import / export syntax */
  facade: boolean
}
/**
 * Outputs the list of exports and locations of import specifiers,
 * including dynamic import and import meta handling.
 *
 * # Panics
 *
 * * File extension is invalid
 */
export function moduleLexerSync(sourceText: string, options?: ParserOptions | undefined | null): ModuleLexer
/**
 * # Panics
 *
 * * Tokio crashes
 */
export function moduleLexerAsync(sourceText: string, options?: ParserOptions | undefined | null): Promise<ModuleLexer>
/**
 * Babel Parser Options
 *
 * <https://github.com/babel/babel/blob/main/packages/babel-parser/typings/babel-parser.d.ts>
 */
export interface ParserOptions {
  sourceType?: 'script' | 'module' | 'unambiguous' | undefined
  sourceFilename?: string
  /**
   * Emit `ParenthesizedExpression` in AST.
   *
   * If this option is true, parenthesized expressions are represented by
   * (non-standard) `ParenthesizedExpression` nodes that have a single `expression` property
   * containing the expression inside parentheses.
   *
   * Default: true
   */
  preserveParens?: boolean
}
export interface ParseResult {
  program: string
  comments: Array<Comment>
  errors: Array<string>
}
export interface Comment {
  type: string
  value: 'Line' | 'Block'
  start: number
  end: number
}
/**
 * Parse without returning anything.
 * This is for benchmark purposes such as measuring napi communication overhead.
 *
 * # Panics
 *
 * * File extension is invalid
 * * Serde JSON serialization
 */
export function parseWithoutReturn(sourceText: string, options?: ParserOptions | undefined | null): void
/**
 * # Panics
 *
 * * File extension is invalid
 * * Serde JSON serialization
 */
export function parseSync(sourceText: string, options?: ParserOptions | undefined | null): ParseResult
/**
 * Returns schema for AST types
 *
 * # Panics
 * Panics if type definitions cannot be converted to JSON.
 */
export function getSchema(): string
/**
 * Create a buffer for use with `parse_sync_raw`.
 * # Panics
 * Panics if cannot allocate buffer.
 */
export function createBuffer(): Uint8Array
/**
 * Returns AST as raw bytes from Rust's memory.
 *
 * Caller provides a buffer.
 * Source text must be written into the start of the buffer, and its length provided as `source_len`.
 * This function will parse the source, and write the AST into the buffer, starting at the end.
 * It also writes to the buffer after the source text:
 * * Offset of `Program` in the buffer.
 * * Mask for converting 64-bit pointers to buffer offsets.
 *
 * # SAFETY
 * Caller must ensure:
 * * Source text is written into start of the buffer.
 * * Source text's byte length is `source_len`.
 * * Source text is valid UTF-8.
 *
 * If source text is originally a JS string on JS side, and converted to a buffer with
 * `Buffer.from(str)` or `new TextEncoder().encode(str)`, this guarantees it's valid UTF-8.
 *
 * # Panics
 * Panics if AST takes more memory than expected.
 */
export function parseSyncRaw(buff: Uint8Array, sourceLen: number, options?: ParserOptions | undefined | null): void
/**
 * # Panics
 *
 * * Tokio crashes
 */
export function parseAsync(sourceText: string, options?: ParserOptions | undefined | null): Promise<ParseResult>
